原文地址：[https://github.com/getify/You-Dont-Know-JS/blob/master/up%20&%20going/ch3.md](https://github.com/getify/You-Dont-Know-JS/blob/master/up%20&%20going/ch3.md)

# 你不知道的JS: 起步
# 第三章: 进入你不知道的JS

我们这个系列主要讲了什么内容呢？简单地说，它讲了学习*JavaScript的方方面面*，而不仅仅是某些人所谓的语言“好的部分”，也不仅仅是完成工作所需的必要部分。

其他语言的严肃的开发人员期望努力学习他们主要语言的全部，但是JS开发人员似乎有些与众不同，通常不会很深入学习自己的语言。这不是一件好事，这不是我们应该继续做的事情。

*你不知道的JS*(*YDKJS*)系列与典型的学习JS的方法形成鲜明对比，并且几乎与你读的任何其他JS书不同。它挑战你的舒适区，并要求你深入每一个语言行为的“为什么”。你愿意接受这个挑战吗？

我将使用这个最后一章简要总结一下系列中其他书的内容，以及如何最有效地建立一个基于*YDKJS*的JS学习基础。

## 作用域与闭包

你可能需要快速掌握的一个最基本的概念是，JavaScript作用域中的变量究竟怎样工作。关于作用域模糊不清地*理解*是远远不够的。

*作用域与闭包*在一开始就驳斥一个比较普遍的误解，即JS是一个『解释型语言』，因此代码不会编译。这是不对的。

在代码执行前（有时是执行时！），JS引擎会编译你的代码。因此，我们更深入地了解编译器处理我们代码的方法，了解它如何发现和处理变量和函数的声明。通过这种方法，我们看到了JS变量作用域管理的一个典型隐喻，『作用域提升』。

在本书的最后一章，我们会探索闭包来深入理解『词法作用域』。闭包可能是JS中最重要的单个概念，但是如果没有作用域的知识来铺垫，你可能不会理解闭包太深。

正如我们在第二章讲的，闭包的一个重要应用就是模块模式。模块模式几乎是JavaScript中最常用的代码组织方式；对它的深刻理解应该是你的最高优先事项之一。

## this与对象原型

也许对JavaScript最广泛和持久的错误之一是，`this`关键字指的是它出现的函数。这非常错误。

`this`关键字是动态绑定的，跟所在函数究竟如何执行有关，有四条简单的规则来理解和确定`this`的绑定关系。

对象原型机制，即向上查看属性的链条，跟`this`关键词关系密切，有点像词法作用域变量的查找过程。但是原型中包含着另一个关于JS的大错误：仿真（假）类和（所谓的“原型”）继承的想法。

不幸的是，将类和继承的设计模式思维带入JavaScript是一件糟糕的事情，因为虽然这种语法可能会让你认为类存在的错觉，事实上原型机制的表现基本上是其相反的行为。

问题是，你选择忽略不匹配，假装你实现的是“继承”会更好，或者学习和拥抱对象原型系统的实际工作原理会更合适。后者更恰当的名称是“行为委托”。

这不仅仅是语法偏好。属性委托是一个完全不同的，更强大的设计模式，它代替了类和继承的设计。但是这些假设的讨论绝对会出现在几乎所有其他博客文章，书籍和会议，贯穿着整个JavaScript的生命。

我关于委托与继承的看法不是来自于对语言及其语法的厌恶，而是来自于希望看到语言的真正能力得以正确利用，无尽的混乱和沮丧得以消除。

但我想讲的关于原型和属性委托远远不止我在这里所讲的。如果你准备重新思考你认为你知道的JavaScript“类”和“继承”的一切，我给你机会“吃下红丸”（"take the red pill" *Matrix* 1999）和阅读本系列书的*this和对象原型*的第4-6章。

## 类型与语法

本系列书的第三个主题主要聚焦于解决另一个高度争议的话题：类型转换。可能没有比隐式的类型转换更加另JS开发者困惑的主题了。

到目前为止，传统的看法是，隐式类型转换是语言的“不良部分”，应该不惜一切代价避免。 事实上，有些人甚至把它称为语言设计中的“缺陷”。而且事实上，有些工具的唯一作用就是扫描你的代码，查找你是否在使用这种类型转换。

但是类型转换真的那么混乱，那么糟糕，那么奸诈，你的代码从一开始就完蛋了如果你使用它？

我觉得不是的。在前三章打下类型和值真正怎样工作的基础后，第四章开始介绍类型转换的方方面面。如果我们花些时间来学习，我们会看到类型转换究竟哪些部分令人困惑，哪些部分是非常有道理的。

我并不是仅仅解释类型转换是合理的和值得学习的，而是我认为类性转换是一个非常有用并且被低估的工具，并且*你应该在你的代码中使用*。我认为正确地使用类型转换不仅会让代码正常工作，并且会让代码变得更好。可能会有很多人认为这是一个笑话，但是我坚信这是提升你的JS能力的关键一点。

你会随大流认为类型转换一无是处，还是会搁置偏见，从一个新的视角审视类型转换？本系列书的*类型与语法*会让你思考。

## 异步与性能

本系列书的的前三个主题关注于语言的核心机制，但是第四个主题相当于独立的分支，关注语言管理异步编程的机制。异步编程不仅影响着我们程序的程序，并且越来越成为我们代码的易写性和可维护性的*关键因素*。

这本书一开始澄清了一些令人困惑的术语和概念，比如『异步』，『并行』以及『并发』，并且深入解释了这些东西在JS上使用怎样合适以及怎样不合适。

然后我们介绍了异步编程的一个主要方式，即回调函数。但是我们会很快看到对于现代异步编程的需求，回调函数是无法满足的。我们会看到回调函数两个主要的不足：无法被信任的*控制反转*（IoC）以及线性的逻辑顺序。

为了解决这两个主要不足，ES6引入了两个新的机制（实际上是模式）：promises和generators。

Promises是对一个『未来值』的与时间无关的包裹，你可以思考和组合这个值无论这个值是否准备好。此外，它使用了可信赖和可组合的promise机制，解决了IoC的信任问题。

Generators引进了一种新的JS函数的执行模式，generator可以在`yield`的点暂停执行并且可以在之后异步地继续执行。这种暂停-继续的能力让generator中看似同步顺序的代码异步地执行。这样做，我们就解决了回调函数的非线性，非本地跳转的问题，因此我们的异步代码看起来像是同步的，这样更加合理。

到目前为止JavaScript依靠promises和generators的组合"yields（产生）"出了最有效的异步编程模式。事实上，未来ES7以及以后的版本中异步编程的大部分内容肯定会建立在这个基础上。要想真正写出有效的异步编程代码，你将需要非常熟练地结合使用promises和generator。

如果promises和generator让我们的程序运行更加并发，从而在更短的时间内完成更多的处理，JS还有许多其他方面的性能优化值得探索。

第5章探讨了Web Workers程序并行性、SIMD数据并行性以及像ASM.js这样的低级优化技术等主题。第6章从通用的基准测试技术的角度来看性能优化，包括什么样的性能表现需要担心以及什么样的需要忽略。

写出有效的JavaScript的代码意味着编写代码，可以打破在大量浏览器和其他环境中动态运行的约束限制。要让一个程序从『可以工作』到『工作地很好』需要我们大量复杂和详细的规划和努力。

*异步与性能*主题会给很多写出合理和高性能的JavaScript代码的工具和技巧。

## ES6及其之外

无论你现在觉得已经掌握多少关于JavaScript的知识，实际上JavaScript实在不停地进化，而且进化速度越来越快。本系列书的名字有一个隐喻，即我们永远无法*知道*JS的方方面面，因为你学习的速度是赶不上新事物产生的速度的。

本主题致力于介绍语言的短期和中期远景，不只是像ES6这种*已知的*，并且包含*潜在的*之外的东西。

本系列书的所有主题都是有关JavaScript在本书写作时的当前状态，正是处于ES6时期，本系列书的关注点已经不仅仅是ES5了。现在，我们要将我们的关注点转向ES6，ES7，...

本书写作时ES6的标准正在逐步完成，*ES6及其之外*将ES6分成几部分来介绍，包括新语法，新数据结构（集合）以及新的处理能力和一些API。在本书中，我们在不同等级的细节上覆盖到了各种ES6的新特性，包括复习本系列其他书相关的细节。

本书将会介绍一些令人兴奋的ES6特性：解构，默认参数值，symbols，方法简写（concise methods），计算属性，箭头函数，块级作用域，promise，generator，iterator，module，proxy，weakmap等等！唷，ES6的东西可真不少！

这本书的第一部分是一个路线图，所有你需要学习到的新的和改进的JavaScript，这些东西你将在接下来的几年内编写和探索。

本书的后半部分将注意力转向简要浏览不久的将来的JavaScript。这里最重要ES6之后的事情，JS可能会随着特性的演进而进化，而不仅仅是版本的变化，这意味着我们可以看到这些近乎未来的东西比你想象来的更快。

JavaScript的未来是光明的。难道现在不是我们开始学习它的时间吗？

## 复习

*YDKJS*系列的书籍的初衷就是让所有JS开发者可以并且应该学到这个伟大语言的所有部分。别人的意见，框架的限制，项目的最后期限都不应该是你不深入学习JavaScript的理由。

我们关注语言的每一个重点，并奉献一个简短但非常密集的书，以充分探索语言的所有部分，这些部分你可能认为你知道，但可能并不完全理解。

『你不知道JS』并不是一个批评或讽刺。这是我们所有人都必须拥有的一个意识，包括自己。学习JavaScript不是最终目标，而是一个过程。我们还不知道JavaScript。但是我们将来会的！
