> 原文地址：[https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md)

# 你不知道的JS：作用域与闭包
# 第一章：什么是作用域

在变量中存储值，然后取出或者修改它，这是几乎所有的编程语言一个最基础的范式。实际上，这种存储值和拉取值的范式实现了一段程序*状态*的改变。

如果没有这种概念，程序或许可以完成某些任务，但是它们受到极大的限制，变得不那么有趣。

但是引入变量的机制会引起一个我们将要讲到的有趣的问题：这些变量*生活*在哪儿？换句话说，它们被存储在哪儿？此外，更重要的是，我们的程序在需要时怎样找到它们？

这些问题说明需要一套明确定义的规则，用于指导在某个位置存储变量，并在以后找到这些变量。我们将这套规则称为：*作用域*。

但是，这些*作用域*规则在哪里被设置？如何被设置？

## 编译器理论

虽然JavaScript被划归为“动态”或“解释”型语言，但实际上它是一个编译型语言。这对有些人来说是不言而喻的，对于有些人来说相当惊讶，取决于你的各种语言的熟悉程度。它*不*像很多传统语言提前就编译好，编译的结果可以在各种分布式系统中移植。

尽管如此，JavaScript引擎执行了许多相同的步骤，但是要比我们通常见到的传统语言编译器更复杂。

在传统的编译语言过程中，一段代码，你的程序在执行*前*，一般会经历三个步骤，总称为『编译』。

1. **标记/分词（Tokenizing/Lexing）：** 将一个字符串拆成有意义（对于语言来说）的片段，即标记。比如，看这段程序：`var a = 2;`。这段程序将可能被拆为以下标记：`var`，`a`，`=`，`2`和`;`。空格是否被识别为标记，取决于它是否有意义。

	**注意：** 标记和分词之间的区别是微妙的和学术的，但它的核心是识别这些标记是否以无状态或有状态的方式。简单地说，如果分词器调用有状态的解析规则来确定`a`是一个单独的标记，还是只是另一个标记的一部分，这就是分词。

2. **解析（Parsing）：** 加一个标记的流（队列）转换成一个嵌套元素的树，这棵树总体表达了程序的语法结构。这棵树称为『抽象语法树（AST）』（<b>A</b>bstract <b>S</b>yntax <b>T</b>ree）。

	语句`var a = 2;`的抽象语法树，最顶层的节点称为`VariableDeclaration`，之下有个称为`Identifier`（值为`a`）的节点，另外一个孩子是`AssignmentExpression`,它的孩子是`NumericLiteral`（值为`2`）。

3. **代码生成：** 经一个抽象语法树转换为可执行代码的过程。这个部分跟语言以及目标平台等有很大关系。

	那么，与其深陷细节，不如我们只是简单地知道这一步是将我们之前的`var a = 2;`抽象语法树转换为一组机器指令，这些指令实际上*创建*了一个叫做`a`的变量（包括预留内存等），然后在`a`上存储了一个值。

	**注意：** 我们并不会深入语言引擎是如何管理系统资源的，我们只需知道引擎能够根据需要创建和存储变量。

与大多数进行以上三步的语言编译器相比，JavaScript引擎更加复杂。比如，在解析和代码生成阶段，JavaScript引擎会进行优化执行性能的步骤，包括合并冗余元素等。

因此，我只是很粗略地在介绍。但是我想你将会很快看到为什么我们*要*覆盖到*这些*细节，即使在一个很高的层次，它们也是相关的。

JavaScript引擎（不像其他语言编译器）并没有太多的优化时间，因为JavaScript并不像其他语言那样，是提前编译的。

对于JavaScript，在很多时候，编译仅仅发生在代码执行前几微妙（或者更少！）。要保证这样的极速性能，JS引擎用了各种魔法（比如JITs，它是延迟编译以及甚至热重编译等），这些都超过了我们要讨论的『范围』。

为简单起见，我们只需知道，任何JavaScript片段都会在执行前（通常*正*当前！）被编译。因此，JS编译器看到`var a = 2;`后，*首先*先将它编译，准备好执行，通常会马上执行。

## 理解作用域

我们将通过思考对话过程来学习关于作用域。但是，*谁*将会是对话的主角？

### 演职表

为了理解接下来的对话，首先让我们见下处理程序`var a = 2;`的角色们。

1. *引擎*：负责从头至尾编译和执行JavaScript程序。

2. *编译器*：*引擎*的朋友；处理所有解析和代码生成（参见前一节）的脏活累活。

3. *作用域*：*引擎*的另一个朋友；收集和维护所有声明的标识符（变量）查找列表，并且拥有一套严格的规则，指导当前执行的代码如何访问这些标识符。

你要想*完全理解*JavaScript如何工作，你需要开始像*引擎*（和它的朋友们）那样*思考*，从它们的角度提出问题并回答这些问题。

### 情节

当你看到程序`var a = 2;`，你很可能认为这是一个语句。但是这不是我们的新朋友*引擎*看待它的方式。实际上，*引擎*看到两条不同的语句，一条用于*编译器*在编译时处理，一条用于*引擎*在执行时处理。

所以，让我们分解*引擎*和它的朋友们将如何处理程序`var a = 2;`。

*编译器*首先要做的是用分词器将这条语句拆解成标记，然后将其解析成抽象状态树。但是当*编译器*开始进行代码生成时，它处理这个程序会有点不同于我们可能的假设。

一个合理的假设是，*编译器*产生代码的过程可以用伪代码这样描述：『为一个变量分配空间，将其标记为`a`，然后将值`2`装入这个变量』。不幸的是，这个描述不是非常准确。

*编译器*将会这样做：

1. 看到`var a`，*编译器*会问*作用域*看是否变量`a`是否在这个特定的作用域集合里已经存在。如果是的话，*编译器*将忽略声明继续前进。否则，*编译器*会请求*作用域*在作用域集合中声明一个叫做`a`的变量。

2. *编译器*产出*引擎*稍后执行的代码，以处理赋值语句`a = 2`。*引擎*上跑的代码会首先询问*作用域*在当前作用域集合中是否有个叫做`a`的变量可供访问。如果是的话，*引擎*就会使用这个变量。如果不是，*引擎*会查看*别处*是否有这个变量（参看下面的嵌套*作用域*一节）。

如果*引擎*最终找到了这个变量，然后会将值`2`赋给它。如果找不到，*引擎*会举起它的手，喊出一个错误！

总结：在一个变量赋值语句中会进行两个不同的动作：首先，*编译器*声明一个变量（如果在当前作用没有声明过），然后当执行时，*引擎*会在*作用域*中查找这个变量，如果找到就赋值给它。

### 编译器说

我们需要了解一些更多的编译器术语，以进一步理解。

当*引擎*执行*编译器*在第（2）产出的代码时，它会向*作用域*查找变量`a`是否已经声明。但是*引擎*查找的结果与其查找方式有关。

在我们这个例子中，*引擎*对于变量`a`将执行『LHS』查找。 此外还有一种查找类型称为『RHS』。

我猜你可能会疑惑『L』和『R』是什么意思。这些术语代表『左手侧』和『右手侧』。

什么的一侧？**赋值操作符。**

或句话说，当变量出现在赋值操作的左侧时，进行LHS查找，并且当变量出现在赋值操作的右侧时，进行RHS查找。

事实上，让我们更精确些。RHS查找是不容易分辨的，跟我们的目的有关，只是简单地查看一些变量的值，然而LHS查找试图找到变量的容器本身，因此可以分配值。这样来说RHS并不*真*的表示『赋值操作的右手边』，它只是，更准确地说，表示『非左手侧』。

稍微不正式一点，你可以认为『RHS』表示『提取他/她的资源（值）』，表示『去获取...的值』。

让我们更深入一些：

当我说：

```js
console.log( a );
```

这里对`a`的引用就是一个RHS引用，因为这里没有给`a`赋值。而是，我们查找并提取`a`的值，这样这个值就可以被传入`console.log(..)`。

相反：

```js
a = 2;
```

这里对`a`的引用就是一个LHS引用，因为我们并不关心它当前的值是多少，我们只是想要找到这个变量，作为`= 2`赋值操作的目标。

**注意：** LHS和RHS表示『赋值表达式的左手侧/右手侧』并不需要逐字理解为『`=`的左手侧/右手侧』。产生赋值的方式有很多，因此最好是从概念上考虑它们：『谁是赋值的目标（LHS）』以及『谁是赋值的源头（RHS）』。

考虑这段代码，同时包含LHS和RHS引用：

```js
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

最后一行调用函数`foo(..)`需要一次对`foo`的RHS引用，表示『去找到`foo`的值，把它给我』。同时`(..)`表示`foo`的值应该被执行，因此它最好是一个函数！

这里有一个细微但是重要的赋值操作。**你注意到了吗？**

你可能会没有注意到在这个代码片段中隐式的`a = 2`。当值`2`被**分配**给参数`a`时，这个赋值就会发生。要（隐式地）赋值给参数`a`，一次LHS就会被执行。

接下来对于`a`的值会进行RHS引用，同时这个结果会被传入`console.log(..)`。`console.log(..)`要执行需要一个引用。包括对`console`对象的RHS查找，然后会进行属性解析，看它是否拥有一个叫做`log`的方法。

最后，在将值`2`（对变量`a`的RHS查找）传入`log(..)`时也会同时发生LHS和RHS。在`log(..)`的内部实现中，我们假设它拥有参数，第一个参数（可能叫做`arg1`）在将`2`赋给它之前，会进行LHS引用查找。

**注意：** 你可能会认为函数声明`function foo(a) {...`是一个常规的变量定义和赋值，就像`var foo`以及`foo = function(a){...`一样。这样一来，你会认为函数声明会进行LHS查找。

然而，有个细微但是重要的不同是，*编译器*会在代码生成阶段同时处理函数声明和值的定义，这样当*引擎*执行代码时，并不需要将一个函数『赋值』给`foo`。因此将函数声明想象为LHS查找分配并不合适。

### 引擎与作用域的对话

```js
function foo(a) {
	console.log( a ); // 2
}

foo( 2 );
```

让我们把上面的交换（处理代码片段的过程）想象成一段对话。这段对话可能像这样：

> ***引擎***： 嘿，*作用域*，我想进行对`foo`的RHS查找。听说过他吗？

> ***作用域***： 是啊，我有。*编译器*刚刚在1秒钟之前声明过，他是一个函数。给你。

> ***引擎***： 非常好，多谢！好的，我正在执行`foo`。

> ***引擎***： 嘿，*作用域*，我要对`a`进行LHS查找，听说过他吗？

> ***作用域***： 是啊，我有。*编译器*刚刚把他声明为`foo`的正式参数，给你。
刚刚在1秒钟之前声明过，他是一个函数。给你。

> ***引擎***： 一如既往地靠谱，作用域*。再次感谢。现在，要把`2`赋值给`a`。

> ***引擎***： 嘿，*作用域*，很抱歉又要打扰你。我需要`console`的RHS查找。听说过他吗？

> ***作用域***： 没问题，*引擎*，这就是我整天的工作。是的，我找到了`console`。它是内置的，给你。

> ***引擎***： 非常好。查找`log(..)`。好的，赞，他是一个函数。

> ***引擎***： 呦，*作用域*。你能帮我对`a`进行RHS查找吗？我想我记得他，但是只是需要再检查一遍。

> ***作用域***： 你是对的，*引擎*。是那个家伙，没变，给你。

> ***引擎***： 赞。把`a`的值`2`传给`log(..)`。

> ...

### 测试

检查到目前为止你的理解。确保扮演过*引擎*的角色，与*作用域*进行过一次『对话』。

```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1. 指出所有的LHS查找（三处！）。

2. 指出所有的RHS查找（四处！）。

**注意：** 测试答案见于本章回顾！

## 嵌套作用域

我们说过，*作用域*是一组规则，用于根据标识符名称来查找变量。然而，我们通常有不止一个*作用域*需要考虑。

就像一个块或者函数被嵌套在另一个块或者函数中，作用域也会被嵌套在另一个作用域中。因此，如果一个变量在当前直接的作用中找不到的话，*引擎*会向外层容器作用域逐层查找，直到找到这个变量或者到达最外层（又称，全局）作用域。

考虑：

```js
function foo(a) {
	console.log( a + b );
}

var b = 2;

foo( 2 ); // 4
```

对于`b`的RHS查找在函数`foo`内部是无法完成的，但是在其外层*作用域*（这个例子中是全局作用域）就能找到。

因此，回顾*引擎*和*作用域*之间的对话，我们会听到如下内容：

> ***引擎***： 嘿，`foo`*作用域*。听说过`b`吗？你能帮我对`b`进行RHS查找吗？

> ***作用域***： 不，没听说过。你得去别的地方看看。

> ***引擎***： 嘿，`foo`的外层*作用域*，噢，你是全局*作用域*，好的，赞。听说过`b`吗？你能帮我对`b`进行RHS查找吗？

> ***作用域***： 是的，听过啊。给你。

遍历嵌套*作用域*的简单规则：*引擎*从当前代码执行的*作用域*开始查找变量，如果没有找到，继续向上一层作用域查找，……。直到最外层全局作用域，无论找到或没找到变量，搜索停止。

### 建筑比喻

请看下面这个高层建筑，图像化地展示了嵌套*作用域*解析的处理过程。

<img src="https://github.com/getify/You-Dont-Know-JS/raw/master/scope%20&%20closures/fig1.png" width=250>

这个建筑展示了我们程序嵌套作用域的规则。无论你在哪儿，建筑的第一层是你当前的执行*作用域*。最高层是全局*作用域*。

通过在当前层查找来解决变量的LHS和RHS引用，如果你没有找到变量，坐着电梯来到下一层，在那里查找，然后继续……。一旦你到达了最顶层（全局*作用域*），你可能找到或者没有找到。但是无论如何，你都要停止了。

## 错误

为什么我们要费劲心机区分LHS和RHS？

因为这两种类型的查找在变量没有声明（没有在任何访问过的*作用域*中找到）的情况下的行为是不同的。

考虑：

```js
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

当第一次对于`b`的RHS查找时，它是不会被找的。这就是所谓的『未声明』变量，因为在作用域中找不到声明。

如果在嵌套作用域中，对于一个变量的RHS查找失败了，结果就是*引擎*会抛出`ReferenceError`错误。要注意的一点是，这个错误的类型是`ReferenceError`。

相反，如果*引擎*进行LHS查找时，直到顶层（全局*作用域*）都没有找到，同时程序没有运行在『严格模式』[^note-strictmode]，此时*作用域*会**在全局作用域中**创建一个新的变量，并把它给*引擎*。

*"不，之前没有这个变量，但是我乐于创建一个给你。"*

ES5中新加的『严格模式』有很多与正常/松散/懒惰模式行为不同之处。其中一个就是，它不允许自动/隐式地创建全局变量。在这个例子中，LHS查找没有找到变量时，并不会有全局*作用域*的变量呈送给*引擎*，而是像RHS一样，抛出一个`ReferenceError`错误

现在，如果一个变量在RHS查找中可以找到，但是你拿它去做一些事情有时也是不行的。比如将一个非函数的值当成函数去执行，或者引用一个`null`或`undefined`值上的属性，此时*引擎*将会抛出另一种错误，称为`TypeError`。

`ReferenceError`是*作用域*解析失败造成的，而`TypeError`意味着*作用域*解析成功了，但是在结果上执行了非法/不可能的行动。

## 回顾 (TL;DR)

作用域就是一组规则，决定了在哪里和怎样找到变量（标识符）。这种查找的目的可能是要给变量赋值，即LHS（左手侧）引用，也可能是提取变量的值，即RHS（右手侧）引用。

左手侧引用是由赋值操作产生的。*作用域*相关的赋值可能会发生在使用`=`操作符时，也可能发生在给函数传递参数时。

JavaScript*引擎*在执行代码前，首先会编译代码，这样的话，它会把像`var a = 2;`这样的语句拆成独立两步：

1. 首先，`var a`是在*作用域*中声明变量。这一步会在代码执行前的一开始就进行。

2. 然后，`a = 2`是查找变量（LHS引用），并且在找到它时进行赋值操作。

LHS和RHS引用查找都是从当前执行的*作用域*开始，如果需要的话（即在当前作用域没有找到要找的变量），这种查找会在嵌套*作用域*继续进行，一次一个作用域（层）地来找标识符，无论变量是否找到，到达全局作用域（顶层）时，查找会停止。

未能完成的RHS引用会引起`ReferenceError`被抛出。未完成的LHS引用会自动产生一个隐式创建的全局变量（如果在是非『严格模式』下），或者一个`ReferenceError`（如果是『严格模式』下）。

### 测试答案

```js
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo( 2 );
```

1. 指出所有的LHS查找（三处！）。

	**`c = ..`，`a = 2` (隐式参数赋值)以及`b = ..`**

2. 指出所有的RHS查找（四处！）。

    **`foo(2..`，`= a;`，`a + ..`以及`.. + b`**


[^note-strictmode]: MDN: [Strict Mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode)
