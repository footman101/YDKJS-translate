> 原文地址：[https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md)

# 你不知道的JS：作用域与闭包
# 第四章：变量提升

到目前为止，你应该适应了作用域的概念，了解了变量是怎样根据定义位置的不同附着于不同层级的作用域的。函数作用域以及块级作用域的表现都遵守这一规则：在一个作用域内任何定义的变量都将附着于这个作用域。

但有一个细节需要考虑，这些变量定义可能出现在作用域的任何位置，此时作用域的附着功能如何工作？这就是我们在这要讨论的问题，

## 鸡还是蛋？

大家很容易认为，你在JavaScript程序中的看到的所有代码是一行一行解释的，从上到下，随着程序的执行。这大致上是对的，这个假设可能会导致你思考程序不正确。

考虑这段代码：

```js
a = 2;

var a;

console.log( a );
```

你期望`console.log(..)`语句打印出什么？

很多开发者期望是`undefined`，由于`var a`语句出现在了`a = 2`语句之后，很自然地认为变量被重复定义了，因此默认被赋值为`undefined`。然而，这个输出是`2`。

考虑另一段代码片段：

```js
console.log( a );

var a = 2;
```
你可能很容易认为，由于前一段代码片段展现出了非从上到下的查看行为，那么在这段代码中，`2`将会被打印。另外一些人可能会认为变量`a`在定义前使用，这将会抛出一个`ReferenceError`。

不幸的是，两种猜测都是不对的。输出是`undefined`。

**那么，这到底是怎么回事儿？** 我们貌似是面对一个鸡还是蛋的问题。哪一个先出来？定义("egg")？还是赋值("chicken")?

## 编译器又来了

要回答这个问题，我们要回到第一章，关于编译器的讨论。回想起*引擎*实际上会在解释JavaScript代码前编译它。编译的一个阶段就是找到所有的变量定义并把它们关联到合适的作用域。第二章给我们展示了这是词法作用域的核心。

那么，思考这些变量和函数定义的最好方式是，它们在你代码任何部分执行之前被预先处理了。

当你看到`var a = 2;`，你可能认为这是一条语句。但是JavaScript实际上会认为这是两条语句：`var a;`和`a = 2;`。第一条语句，定义语句，在编译阶段被处理。第二条语句，赋值语句，被留在了*原地*，到了执行阶段才执行。

那么我们的第一段代码片段应该被认为这样处理：

```js
var a;
```
```js
a = 2;

console.log( a );
```

第一部分是在编译阶段，第二部分是在执行阶段。

相似的，我们的第二段代码实际是这样处理的：

```js
var a;
```
```js
console.log( a );

a = 2;
```

那么，关于这个处理过程，我们可以这样认为，变量和函数定义从它们在代码流出现的位置『移动』到了代码的开头。这种移动被称为『提升』。

换句话说，**蛋（定义）在鸡（赋值）之前出现**。

**注意：** 只有定义本身被提升了，而任何赋值以及其他执行逻辑被留在了*原地*。如果提升会重新排列我们代码的执行逻辑，那将会是大破坏。

```js
foo();

function foo() {
	console.log( a ); // undefined

	var a = 2;
}
```

`foo`函数的定义（在此例中*包括了*它的隐式值，即实际的函数）被提升了，因此第一行中的函数调用可以执行。

同时，需要注意的是，提升是**在每一个作用域中的**。因此我们之前的代码片段只包括全局作用域，比较简单，这里的`foo(..)`本身就是一个作用域，内部的`var a`被提升到了`foo(..)`的开始（而不是，明显的，整个程序的开始）。因此整段程序可能更加准确地这样解释：

```js
function foo() {
	var a;

	console.log( a ); // undefined

	a = 2;
}

foo();
```

函数定义被提升了，就像我们说的。但是函数表达式却不是这样。

```js
foo(); // not ReferenceError, but TypeError!

var foo = function bar() {
	// ...
};
```

变量标识符`foo`被提升并附着到了这段程序的包裹作用域（全局作用域）。因此`foo()`并没有抛出`ReferenceError`，但是`foo`此时并没有值（它是一个函数表达式而不是一个真正的函数定义）。因此，`foo()`这里相当于调用了`undefined`值，会抛出`TypeError`非法操作。

同时，即使这是一个命名的函数表达式，名称标识符依旧在包裹作用域中不可用：

```js
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
	// ...
};
```

这段代码更准确地是这样（带着提升）解释：

```js
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
	var bar = ...self...
	// ...
}
```

## 函数优先

函数定义和变量定义都会被提升。但是有一个细微的细节（*可以*在代码有『重复』定义时出现）是，函数会被优先提升，其次是变量。

考虑：

```js
foo(); // 1

var foo;

function foo() {
	console.log( 1 );
}

foo = function() {
	console.log( 2 );
};
```

`1`会被打印出来而不是`2`！这段代码被*引擎*这样解释：

```js
function foo() {
	console.log( 1 );
}

foo(); // 1

foo = function() {
	console.log( 2 );
};
```

注意即使`var foo`定义出现在`function foo()...`之前，它也是被重复（因此被忽略）定义了，因为函数定义提升优先于正常的变量定义。

多重/重复`var`定义实际上被忽略了，随后的函数定义*确实*覆盖了之前的定义。

```js
foo(); // 3

function foo() {
	console.log( 1 );
}

var foo = function() {
	console.log( 2 );
};

function foo() {
	console.log( 3 );
}
```

这里可能听起来是些有趣的学院派琐事，但它确实说明了，在同一作用域中的重复定义是一件非常不好的事，可能会引起令人疑惑的结果。

正常代码块中的函数定义一般会提升到包裹作用域，而不会像相面这段代码描述的条件选择那样：

```js
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```

然而，要注意的是，这种行为是不可靠的，将来的JavaScript版本中可能会修改，所以，最好不要这样在代码块中定义函数。

## 回顾（TL;DR）

我们可能认为`var a = 2;`是一条语句，但是JavaScript*引擎*并不这样认为。它认为`var a`和`a = 2`是分开的语句，第一条是编译阶段的任务，第二条是执行阶段的任务。

这样会导致一个结果，即在一个作用域中的所有定义，无论它们出现在哪里，会在代码执行之前*首先*被处理。你可以这样形象地认为，这些定义（变量和函数）被『移动』到了它们各自作用域的头部，这一过程我们称之为『提升』。

定义本身被提升了，然而赋值，即使函数表达式的赋值*没有*被提升。

注意重复定义，尤其是混合使用正常的var定义以及函数定义 -- 如果这样做，危险在等着你！
