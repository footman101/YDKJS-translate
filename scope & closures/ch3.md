> 原文地址：[https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md)

# 你不知道的JS：作用域与闭包
# 第三章：函数作用域与块作用域

正如我们在第二章看到的，作用域由一系列『泡泡』组成，这些泡泡就像一个容器或者篮子，在这里定义了标识符（变量，函数）。这些泡泡整齐地层层嵌套，这些嵌套是在书写时定义的。

但是究竟是什么创建了一个新的泡泡？仅仅是函数吗？JavaScript中的其他结构可以创建作用域泡泡吗？

## 从函数创建的作用域

这些问题最常见的回答是，JavaScript具有以函数为基础的作用域。即，你定义的每一个函数为它自己创建了一个泡泡，其他的结构都不会创建它们自己的作用域泡泡。我们接下来会看到，这并不是完全正确的。

但是首先，让我们先探究下函数作用域以及它的实现。

考虑以下代码：

```js
function foo(a) {
	var b = 2;

	// some code

	function bar() {
		// ...
	}

	// more code

	var c = 3;
}
```

在这个片段中，`foo(..)`作用域泡泡包括标识符`a`，`b`，`c`以及`bar`。它们在作用域中声明的*地方***无关紧要**，变量或者函数无论如何都属于包裹着它们的作用域泡泡。我们将会在下一章节探索*这*是如何工作的。

`bar(..)`拥有它自己的作用域泡泡。全局作用域也是一样，它只有一个标识符：`foo`。

因为`a`，`b`，`c`以及`bar`都属于`foo(..)`的作用域泡泡，他们在`foo(..)`以外是无法被访问的。即，以下代码全部会产生`ReferenceError`错误，因为这些标识符在全局作用域是访问不到的：

```js
bar(); // fails

console.log( a, b, c ); // all 3 fail
```

然而，所有这些标识符（`a`，`b`，`c`，`foo`和`bar`）在`foo(..)`*内部*是可以访问的，同时在`bar(..)`内部也是可以访问的（假设在`bar(..)`内部没有标识符定义阴影）。

在函数作用域中，所有变量属于函数，并且可以在整个函数（甚至可访问的嵌套作用域）中使用和重用。 这种设计方法是非常有用的，可以充分利用JavaScript变量的『动态』性质，根据需要承担不同类型的值。

另一方面，如果您不采取谨慎的预防措施，整个作用域内存在的变量可能会导致一些意想不到的陷阱。

## 在作用域中隐藏代码

思考函数的传统方式是声明一个函数，然后在其中添加代码。但反向思维同样强大和有用：可以将您编写的任何代码段，包装在一个函数声明中，这样做实际上『隐藏』了代码。

将一段代码包裹在一个作用域泡泡中，这意味着这段代码中的任何声明（变量或者函数）将会绑定到新的包裹函数作用域中，而不是之前的作用域。换句话说，你可以通过用函数包裹变量和函数来达到『隐藏』的目的。

为什么『隐藏』变量和函数是一项有用的技术？

这种基于作用域的隐藏有各种各样的原因。这种隐藏符合软件设计原则『最低权限原则』[^ note-leastprivilege]，有时也称为『最低权限』或『最低限度曝光』。这个原则指出，在软件设计（如模块/对象的API）中，你应该仅仅暴露最低限度的必需内容，并『隐藏』所有其他内容。

这个原则可以扩展到选择哪个作用域包含变量和函数。如果所有变量和函数都在全局作用域内，则它们可以被任何嵌套的作用域访问。但是这样做会违反『最小...』原则，因为你(可能)会暴露了过多的变量或函数，然而这些变量或函数应该保持私有，正常使用代码时并不希望访问到这些变量/函数。

例如：

```js
function doSomething(a) {
	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

function doSomethingElse(a) {
	return a - 1;
}

var b;

doSomething( 2 ); // 15
```

在这段代码中，变量`b`和函数`doSomethingElse(..)`应该是`doSomething(..)`函数的『私有』细节。将`b`和`doSomethingElse(..)`暴露给外层作用域『访问』不仅是不必要的，并且可能是『危险的』，它们可能被有意无意地在意料之外使用，这样会侵犯函数`doSomething(..)`的既有假设。

一个更『好』的实践是将这些私有细节隐藏在`doSomething(..)`作用域中，例如：

```js
function doSomething(a) {
	function doSomethingElse(a) {
		return a - 1;
	}

	var b;

	b = a + doSomethingElse( a * 2 );

	console.log( b * 3 );
}

doSomething( 2 ); // 15
```

现在`b`和`doSomethingElse(..)`不能被外部访问到，而只能被`doSomething(..)`函数控制。它的功能性和实际结果不会被收到影响，保持私有细节私有，这通常被认为是更好的软件设计。

### 避免冲突

在一个作用域中『隐藏』变量和函数的另一个好处是，可以避免两个不同标识符之间的意外冲突，这两个标识符的名称相同，但不同的用途。碰撞往往导致值被意外地重写。

例如：

```js
function foo() {
	function bar(a) {
		i = 3; // changing the `i` in the enclosing scope's for-loop
		console.log( a + i );
	}

	for (var i=0; i<10; i++) {
		bar( i * 2 ); // oops, infinite loop ahead!
	}
}

foo();
```

在`bar(..)`中赋值语句`i = 3`，意外地，重写了`foo(..)`中for循环中定义的`i`。这将会引起无限循环，因为`i`被设置为固定值`3`，它将永远`< 10`。

`bar(..)`中的赋值语句，无论使用什么标识符名称，都应该声明一个本地变量来使用。`var i = 3;`可以修复上述问题（将会创建一个之前提到的`i`的『变量阴影』）。一个*附加的*，而不是替代的选项是选择另一个标识符名称，例如`var j = 3;`。但是，您的软件设计可能自然地要求相同的标识符名称，因此利用作用域『隐藏』你的内部声明是你最佳/唯一选项。

#### 全局『命名空间』

在全局作用域内（可能）发生变量冲突的一个特别强大的例子：如果加载到程序中的多个库不能正确隐藏其内部/私有函数和变量，那么它们很容易相互碰撞。

这些库一般会创建一个单变量声明，通常是一个对象，它在全局作用域中拥有足够唯一的名称。这个对象可以看做是这个库的『命名空间』，所有需要暴露的功能会做成这个对象（命名空间）的属性，而不是顶层词法作用域标识符。

例如：

```js
var MyReallyCoolLibrary = {
	awesome: "stuff",
	doSomething: function() {
		// ...
	},
	doAnotherThing: function() {
		// ...
	}
};
```

#### 模块管理

另一个避免冲突的方法是更加现代的『module』方法，使用众多依赖管理中的一种。使用这些工具，没有库会添加任何标识符到全局作用域，而是需要通过使用依赖管理器的各种机制将其标识符显式导入另一个特定的作用域。

应该注意到，这些工具不具有免除词法作用域规则的『魔术』功能。它们只是使用这里所述的作用域规则，来强制不将任何标识符注入到任何共享作用域中，而是保持私有，不受碰撞影响的作用域内，从而防止任何意外的作用域冲突。

因此，如果你选择防御性地进行编码，可以实现与依赖关系管理器相同的结果，而不需要实际使用它们。关于模块模式的更多信息请看第五章。

## 作为作用域的函数

我们已经看到，我们可以将任意一段代码包裹在一个函数中，这样可以有效地在函数内部作用域『隐藏』变量和函数声明，外部作用域是访问不到的。

例如：

```js
var a = 2;

function foo() { // <-- insert this

	var a = 3;
	console.log( a ); // 3

} // <-- and this
foo(); // <-- and this

console.log( a ); // 2
```

这种方式客可以『工作』，但是它不是十分完美。它带来了一些问题。首先是，我们必须定义一个具名函数`foo()`，这样标识符`foo`本身就『污染』了包裹它的作用域（上述代码中是全局作用域）。同时，我们必须使用函数名（`foo()`）显示地调用这个函数，这样其内部的代码才能执行。

如果函数不是必须要一个名称（或者，名称不会污染包裹它的作用域），同时会自动执行将会比较完美。

幸运地是，JavaScript提供了解决这两个问题的方法。

```js
var a = 2;

(function foo(){ // <-- insert this

	var a = 3;
	console.log( a ); // 3

})(); // <-- and this

console.log( a ); // 2
```

让我们看一看这里发生了什么。

首先，要注意到包裹函数语句以`(function...`开头，而不是`function...`。这看起来是不起眼的差别，实际上是最主要的差别。这里的函数是一个函数表达式，而不是一个标准的函数声明。

**注意：** 区分声明和表达式最简单的方法是，单词『function』在语句中的位置（不是仅仅一行，而是一个清晰的语句）。如果『function』在语句的最开头，那么此时是一个函数声明。否则，就是函数表达式。

我们可以看到的函数声明和函数表达式的关键区别在于其名称作为标识符绑定的位置。

比较之前的两段代码。在第一段代码中，名称`foo`绑定到了包裹作用域，我们可以直接使用`foo()`调用这个函数。在第二段代码中，名称`foo`并没有绑定到包裹作用域，而是仅仅绑定到了它本身的函数作用域内部。

换句话说，`(function foo(){ .. })`作为一个表达式，意味着标识符`foo`*只*会绑定在`..`指示的作用域中，而不是外部的作用域。把名称`foo`隐藏在它自身意味着不会不必要地污染包裹作用域。

### 匿名与具名

你可能对作为回调参数的函数表达式很熟悉，例如：

```js
setTimeout( function(){
	console.log("I waited 1 second!");
}, 1000 );
```

这是一个『匿名函数表达式』，因为并没有名称标识符在`function()...`上。函数表达式可以是匿名的，但是函数声明不能没有名称 -- 那将是非法的JS语法。

匿名函数表达式可以被快速而容易地打出，并且很多库和工具鼓励使用这种符合习惯的代码风格。然而，需要考虑它的几个不好之处：

1. 匿名函数在函数调用栈中没有有用的名称用于显示，这将使debug更加困难。

2. 没有名称，如果函数需要引用它自身，比如递归等，此时很不幸就需要使用**已经废弃的**`arguments.callee`。另外一个需要引用自身的例子是，一个事件处理函数在它触发后想要解绑它自身。

3. 匿名函数省略了名称，名称通常有助于提高代码的可读性/可理解性。描述性名称有助于代码的自我注释。

**内联函数表达式**是强大而有用的 -- 匿名和具名的问题不会降低它的有用性。将你的函数表达式具名化非常有效地解决了上述不足之处，并且没有明显的负面效果。最好的实践就是永远命名你的函数表达式：

```js
setTimeout( function timeoutHandler(){ // <-- Look, I have a name!
	console.log( "I waited 1 second!" );
}, 1000 );
```

### 立即调用函数表达式

```js
var a = 2;

(function foo(){

	var a = 3;
	console.log( a ); // 3

})();

console.log( a ); // 2
```

现在我们将函数用一对`( )`包裹，就有了一个函数表达式，我们可以在其后增加另一个`()`来执行函数，如`(function foo(){ .. })()`。第一个包裹`( )`对将函数变成了表达式，第二个`()`执行了这个函数。

这个模式的使用是如此的普遍，几年前社区给它起了个名字：**IIFE**，即立即调用函数表达式（**I**mmediately **I**nvoked **F**unction **E**xpression）。

当然，IIFE必定不需要拥有名称 -- 最常见的IIFE使用方式是使用匿名函数表达式。当然有些情况下，命名一个IIFE相对于匿名函数表达式拥有之前提到的各种好处，因此命名是一个好的实践。

```js
var a = 2;

(function IIFE(){

	var a = 3;
	console.log( a ); // 3

})();

console.log( a ); // 2
```

相对于传统的IIFE形式，有些人喜欢`(function(){ .. }())`，有些轻微的不同。仔细看看它们的区别。在第一种行驶中，函数被`( )`包裹，然后调用`()`在它的之外的右侧。在第二种形式中，调用`()`移动到了外层`( )`包裹对里边。

这两种形式有着相同的效果。**仅仅取决于你更喜欢哪种代码风格。**

另一个IIFE的变化是很常见的，实际上只是函数调用，并传入参数。

例如：

```js
var a = 2;

(function IIFE( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

})( window );

console.log( a ); // 2
```

我们传进了`window`对象的引用，但是我们将这个参数命名为`global`，这样我们可以清晰地从命名风格区分全局和非全局引用。当然，你可以根据所需，从封闭作用域传入任何内容，你可以将参数命名为适合你的任何内容。这大多只是代码风格的选择问题。

这个模式的另一个应用是，（在小的范围内）修正默认的`undefined`标识符可能会将其值错误地覆盖，从而导致意外的结果的问题。将一个参数命名为`undefined`，但是不给这个参数传入任何值，我们就可以保证在代码块中`undefined`标识符确实是undefined值。

```js
undefined = true; // setting a land-mine for other code! avoid!

(function IIFE( undefined ){

	var a;
	if (a === undefined) {
		console.log( "Undefined is safe here!" );
	}

})();
```

还有一种IIFE的变体，可以改变代码的顺序，要执行的函数可以延后给出，在调用和传参*之后*。这种模式在UMD（Universal Module Definition）项目中使用。有些人认为这种模式比较容易理解，即使它有些啰嗦。

```js
var a = 2;

(function IIFE( def ){
	def( window );
})(function def( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

});
```

函数表达式`def`在上述片段的后半部分定义，然后作为参数（也叫`def`）传给了前半部分定义的`IIFE`函数。最后参数`def`（函数）被调用，`window`作为`global`参数被传入。

## 作为作用域的块

虽然函数是最常见的作用域单元，并且肯定是大多数JS代码写法中最广泛的设计方法，其他作用域单元也是可能的，这些其他作用域单元的使用可以产生更好的，更清洁易维护的代码。

JavaScript以外的许多语言都支持块级作用域，因此来自这些语言的开发人员很容易习惯这种思维方式，而那些只使用过JavaScript的人可能会感觉这个概念有些陌生。

但是即使你从来没写过一行块级作用域形式的代码，你依然可能对JavaScript中这种常见的模式十分熟悉：

```js
for (var i=0; i<10; i++) {
	console.log( i );
}
```

我们直接在for循环的头部定义了变量`i`，我们最可能的*意图*是，仅仅在for循环中使用`i`，并且基本会忽略变量实际上是定义在包裹作用域（函数或者全局）上的事实。

这就是块级作用域的意义。尽可能近地定义变量，尽可能离它们使用的地方近一些。另一个例子：

```js
var foo = true;

if (foo) {
	var bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}
```

我们只在if语句中使用了`bar`变量，那么我们在if语句中定义它是合理的。然而，我们定义变量的地方和我们写`var`的地方并没有关系，这些变量仍然属于包裹作用域。这段代码大体上『伪造』了块级作用域，仅仅为了代码风格的原因，要依赖于自己的约束才能不在作用域的另一个地方使用`bar`。

块级作用是将早期的『最低权限~~曝光~~原则』[^ note-leastprivilege]从在函数中隐藏信息扩展到在我们的代码块中隐藏信息的工具。

再次考虑for循环例子：

```js
for (var i=0; i<10; i++) {
	console.log( i );
}
```

为什么用`i`变量污染整个函数作用域？它本来只是（或者至少*应该是*）在for循环中使用。

但更重要的是，开发人员可能更喜欢引擎自己*检查*在自身意图之外（重新）使用变量的意外，比如如果你尝试在错误的地方使用，会一起未知变量的错误。对于`i`变量的块级作用域（如果可能的话）可以使`i`变量只能在for循环中使用，如果`i`在函数的其他地方使用会引起错误。这有助于确保变量不会以混淆或难以维护的方式重新使用。

但是，可悲的现实是，从表面上看，JavaScript没有块级作用域的功能。

也就是说，直到你再深入一点。

### `with`

我们在第二章学习了`with`。虽然它是一个让人皱眉的结构，但它*是*（一种形式的）块级作用域例子，对象创建的作用域仅仅存在于`with`语句的生命周期中，而不是在整个包裹作用域。

### `try/catch`

很少有人知道的是，ES3规范中的JavaScript将`try / catch`中的`catch`子句中的变量声明指定为`catch`块的块级作用域。

例如：

```js
try {
	undefined(); // illegal operation to force an exception!
}
catch (err) {
	console.log( err ); // works!
}

console.log( err ); // ReferenceError: `err` not found
```

你可以看到，`err`仅仅存在于`catch`块中，如果你在别出引用它就会抛出一个错误。

**注意：** 即使这个行为已经有规范说明并且几乎所有的标准JS环境（可能除了老版本的IE）都支持，但是很多语法格式检查工具依然会在以下这种情况中提示错误。你在同一作用域中的两个或多个`catch`块内，分别使用相同的标识符名称定义了自己的error变量。这实际上不是重复定义，因为变量被安全地存放于块级作用域内，但是这些语法格式检查工具依然令人厌烦地提示错误。

要想避免这种不必要的警告，一些开发人员会将他们的`catch`块的变量命名为`err1`, `err2`等等。另外一些人则会直接关掉检查重复变量名称的功能。

`catch`块的块级作用域的天性似乎是一个没用的学院派的事实，但是请参看附录B来了解更多的信息，会了解到它可能是有用的。

### `let`

到目前为止，我们已经看到JavaScript只有一些奇怪的小众行为会暴露块级作用域的功能。如果这是我们所有的，并且*持续*许多许多年，那么块级作用域对JavaScript开发人员来说将不是特别有用。

幸运的是，ES6改变了这个现状，并且介绍了一个新的关键字`let`，它是`var`关键字之外的另一种定义变量的方式。

`let`关键字将变量声明绑定到包含它的任何块（通常是一个`{..}`对）的作用域内。换句话说，`let`隐式地劫持了任何块的作用域来进行变量声明。

```js
var foo = true;

if (foo) {
	let bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}

console.log( bar ); // ReferenceError
```

使用`let`将一个变量绑定在一个存在的块上，这是隐式的。如果你没有密切关注哪些块级作用域内拥有哪些变量，并且在开发和演进代码时习惯于移动块，将其包装在其他块中等等，这可能会让你感到困惑。

创建显式的块级作用域可以解决其中一些问题，使得变量是否绑定更加明显。通常，显式代码优于隐式或微妙的代码。这种显式的块级作用域风格很容易实现，并且更适合其他语言中的块级作用域的工作方式：

```js
var foo = true;

if (foo) {
	{ // <-- explicit block
		let bar = foo * 2;
		bar = something( bar );
		console.log( bar );
	}
}

console.log( bar ); // ReferenceError
```

我们可以在语句有效语法的任何地方简单地使用一个`{..}`对，为`let`绑定创建一个块。在上述代码中，我们在if语句*中*做了一个显式的块，可以更容易地在重构中移动它，而不会影响包裹它的if语句的位置和语义。

**注意：** 更多其他表示显式块级作用域的方法，请参见附录B。

在第四章，我们将讨论命名提升问题，它将变量声明提升至声明所在的整个作用域。

然而，使用`let`的声明*不会*提升至它们所在的块所处的整个作用域。这些声明直到声明语句在块中出现才可以『生效』。

```js
{
   console.log( bar ); // ReferenceError!
   let bar = 2;
}
```

#### 垃圾回收

块级作用域有用的另外一个原因是关于闭包和垃圾回收释放内存。我们将在这里简要说明一下，闭包机制在第5章中会有详细介绍。

考虑：

```js
function process(data) {
	// do something interesting
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
```

`click`函数

`click`函数作为点击处理函数回调并不*需要*使用`someReallyBigData`变量。即理论上，`process(..)`运行过后，这个大块占据很多内存的数据结构可以进行垃圾回收了。然而，（即使实现不同）JS引擎通常很可能保留这个数据结构，因为`click`函数在整个作用域上有一个闭包。

块级作用域可以解决这个问题，可以让引擎清晰地认识到没有必要保留`someReallyBigData`了：

```js
function process(data) {
	// do something interesting
}

// anything declared inside this block can go away after!
{
	let someReallyBigData = { .. };

	process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
```

显示地声明块，将变量绑定在本地是一个很强大的工具，你可以将其加入到你的工具箱中。

#### `let`循环

`let`非常有用的一个场景是在我们之前讨论过的for循环中。

```js
for (let i=0; i<10; i++) {
	console.log( i );
}

console.log( i ); // ReferenceError
```

for循环一开始的`let`不仅将`i`绑定到了for循环体，而且实际上，它会**重新绑定它**到循环的每一次*迭代*，保证将上一轮迭代结束的值赋给新一轮迭代。

这里是一种模拟迭代前绑定行为的代码：

```js
{
	let j;
	for (j=0; j<10; j++) {
		let i = j; // re-bound for each iteration!
		console.log( i );
	}
}
```

迭代前绑定的原因比较有趣，我们在第五章讨论了闭包之后就清楚了。

由于`let`声明绑定到了直接的代码块，而不是被包裹的函数作用域（或者全局作用域），所以存在一些隐藏的依赖于函数作用域里`var`声明的代码，将`var`替换为`let `重构代码时，可能需要格外的小心。

考虑：

```js
var foo = true, baz = 10;

if (foo) {
	var bar = 3;

	if (baz > bar) {
		console.log( baz );
	}

	// ...
}
```

这段代码可以非常容易地重构为：

```js
var foo = true, baz = 10;

if (foo) {
	var bar = 3;

	// ...
}

if (baz > bar) {
	console.log( baz );
}
```

但是，当使用块级作用域变量时要注意这些变化：

```js
var foo = true, baz = 10;

if (foo) {
	let bar = 3;

	if (baz > bar) { // <-- don't forget `bar` when moving!
		console.log( baz );
	}
}
```

参见附录B，可以看到另外一种（更显式的）块级作用域，它可以更容易地维护/重构代码，在这一场景下更加健壮。

### `const`

除了`let`之外，ES6还介绍了`const`，它同样可以创建一个块级作用域变量，但是这个变量是固定的（常量）。在之后任何想要改变它的值的行为都会引起一个错误。

```js
var foo = true;

if (foo) {
	var a = 2;
	const b = 3; // block-scoped to the containing `if`

	a = 3; // just fine!
	b = 4; // error!
}

console.log( a ); // 3
console.log( b ); // ReferenceError!
```

## 回顾 (TL;DR)

函数是JavaScript中最常见的作用域单元。函数中声明的变量和函数本质上对于其被包裹的『作用域』来说是隐藏的，这是一种有意设计的良好软件设计原则。

但是函数并不是唯一的作用域单元。块级作用域表示变量和函数可以属于直接的块（一般的，任何`{ .. }`对），而不是被包裹的函数。

从ES3开始，`try/catch`中的`catch`分句就拥有块级作用域。

在ES6中，介绍了`let`关键字（`var`关键字的近亲），它可以允许变量声明在任何代码块中。`if (..) { let a = 2; }`将会声明一个变量`a`，这个变量本质上劫持了`if`的`{ .. }`块作用域，并附着于此。

虽然有些人似乎相信这一点，但是块级作用域不应该被视为`var`函数作用域的完全替代品。这两个功能共存，开发人员可以并且应该分别使用函数作用域和块级作用域技术，可以写成更好，更可读/可维护的代码。

[^note-leastprivilege]: [Principle of Least Privilege](http://en.wikipedia.org/wiki/Principle_of_least_privilege)
